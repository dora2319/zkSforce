// Copyright (c) 2011,2013,2019 Jonathan Hersh, Simon Fell
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// 
// Note: This file was generated by WSDL2ZKSforce.
//		  see https://github.com/superfell/WSDL2ZKSforce
//       DO NOT HAND EDIT.
//

#import "ZKSforceBaseClient+Operations.h"
#import "ZKErrors.h"

@implementation ZKSforceBaseClient (AsyncOperations)

-(BOOL)confirmLoggedIn {
	return YES; // concrete impl in subclass
}

-(BOOL)handledError:(NSError *)ex failBlock:(ZKFailWithErrorBlock)failBlock {
	if (ex == nil) {
		return NO;
	}
	if (failBlock != nil) {
		dispatch_async(dispatch_get_main_queue(), ^{
			failBlock(ex);
		});
	}
	return YES;
}

/** Login to the Salesforce.com SOAP Api */
-(void) performLogin:(NSString *)username password:(NSString *)password
           failBlock:(ZKFailWithErrorBlock)failBlock
       completeBlock:(ZKCompleteLoginResultBlock)completeBlock {

	NSString *payload = [self makeLoginEnv:username password:password];
	[self startRequest:payload name:@"login" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKLoginResult *result = [self makeLoginResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

-(ZKDescribeSObject *)preHook_describeSObject:(NSString *)sObjectType { return nil; }
-(ZKDescribeSObject *)postHook_describeSObject:(ZKDescribeSObject *)r { return r; }

/** Describe an sObject */
-(void) performDescribeSObject:(NSString *)sObjectType
                     failBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteDescribeSObjectBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	ZKDescribeSObject *shortcut = [self preHook_describeSObject:sObjectType];
	if (shortcut != nil) {
		dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(shortcut);
		});
		return;
	}
	NSString *payload = [self makeDescribeSObjectEnv:sObjectType];
	[self startRequest:payload name:@"describeSObject" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeSObject *result = [self postHook_describeSObject:[self makeDescribeSObjectResult:root]];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe multiple sObjects (upto 100) */
-(void) performDescribeSObjects:(NSArray *)sObjectType
                      failBlock:(ZKFailWithErrorBlock)failBlock
                  completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSObjectsEnv:sObjectType];
	[self startRequest:payload name:@"describeSObjects" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeSObjectsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

-(NSArray *)preHook_describeGlobal { return nil; }
-(NSArray *)postHook_describeGlobal:(NSArray *)r { return r; }

/** Describe the Global state */
-(void) performDescribeGlobalWithFailBlock:(ZKFailWithErrorBlock)failBlock
                completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSArray *shortcut = [self preHook_describeGlobal];
	if (shortcut != nil) {
		dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(shortcut);
		});
		return;
	}
	NSString *payload = [self makeDescribeGlobalEnv];
	[self startRequest:payload name:@"describeGlobal" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self postHook_describeGlobal:[self makeDescribeGlobalResult:root]];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe all the data category groups available for a given set of types */
-(void) performDescribeDataCategoryGroups:(NSArray *)sObjectType
                                failBlock:(ZKFailWithErrorBlock)failBlock
                            completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeDataCategoryGroupsEnv:sObjectType];
	[self startRequest:payload name:@"describeDataCategoryGroups" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeDataCategoryGroupsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the data category group structures for a given set of pair of types and data category group name */
-(void) performDescribeDataCategoryGroupStructures:(NSArray *)pairs topCategoriesOnly:(BOOL)topCategoriesOnly
                                         failBlock:(ZKFailWithErrorBlock)failBlock
                                     completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeDataCategoryGroupStructuresEnv:pairs topCategoriesOnly:topCategoriesOnly];
	[self startRequest:payload name:@"describeDataCategoryGroupStructures" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeDataCategoryGroupStructuresResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe your Data Category Mappings. */
-(void) performDescribeDataCategoryMappingsWithFailBlock:(ZKFailWithErrorBlock)failBlock
                              completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeDataCategoryMappingsEnv];
	[self startRequest:payload name:@"describeDataCategoryMappings" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeDataCategoryMappingsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describes your Knowledge settings, such as if knowledgeEnabled is on or off, its default language and supported languages */
-(void) performDescribeKnowledgeSettingsWithFailBlock:(ZKFailWithErrorBlock)failBlock
                           completeBlock:(ZKCompleteKnowledgeSettingsBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeKnowledgeSettingsEnv];
	[self startRequest:payload name:@"describeKnowledgeSettings" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKKnowledgeSettings *result = [self makeDescribeKnowledgeSettingsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the items in an AppMenu */
-(void) performDescribeAppMenu:(NSString *)appMenuType networkId:(NSString *)networkId
                     failBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteDescribeAppMenuResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeAppMenuEnv:appMenuType networkId:networkId];
	[self startRequest:payload name:@"describeAppMenu" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeAppMenuResult *result = [self makeDescribeAppMenuResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe Gloal and Themes */
-(void) performDescribeGlobalThemeWithFailBlock:(ZKFailWithErrorBlock)failBlock
                     completeBlock:(ZKCompleteDescribeGlobalThemeBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeGlobalThemeEnv];
	[self startRequest:payload name:@"describeGlobalTheme" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeGlobalTheme *result = [self makeDescribeGlobalThemeResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe Themes */
-(void) performDescribeTheme:(NSArray *)sobjectType
                   failBlock:(ZKFailWithErrorBlock)failBlock
               completeBlock:(ZKCompleteDescribeThemeResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeThemeEnv:sobjectType];
	[self startRequest:payload name:@"describeTheme" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeThemeResult *result = [self makeDescribeThemeResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the layout of the given sObject or the given actionable global page. */
-(void) performDescribeLayout:(NSString *)sObjectType layoutName:(NSString *)layoutName recordTypeIds:(NSArray *)recordTypeIds
                    failBlock:(ZKFailWithErrorBlock)failBlock
                completeBlock:(ZKCompleteDescribeLayoutResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeLayoutEnv:sObjectType layoutName:layoutName recordTypeIds:recordTypeIds];
	[self startRequest:payload name:@"describeLayout" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeLayoutResult *result = [self makeDescribeLayoutResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the layout of the SoftPhone */
-(void) performDescribeSoftphoneLayoutWithFailBlock:(ZKFailWithErrorBlock)failBlock
                         completeBlock:(ZKCompleteDescribeSoftphoneLayoutResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSoftphoneLayoutEnv];
	[self startRequest:payload name:@"describeSoftphoneLayout" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeSoftphoneLayoutResult *result = [self makeDescribeSoftphoneLayoutResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the search view of an sObject */
-(void) performDescribeSearchLayouts:(NSArray *)sObjectType
                           failBlock:(ZKFailWithErrorBlock)failBlock
                       completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSearchLayoutsEnv:sObjectType];
	[self startRequest:payload name:@"describeSearchLayouts" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeSearchLayoutsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe a list of entity names that reflects the current user's searchable entities */
-(void) performDescribeSearchableEntities:(BOOL)includeOnlyEntitiesWithTabs
                                failBlock:(ZKFailWithErrorBlock)failBlock
                            completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSearchableEntitiesEnv:includeOnlyEntitiesWithTabs];
	[self startRequest:payload name:@"describeSearchableEntities" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeSearchableEntitiesResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe a list of objects representing the order and scope of objects on a users search result page */
-(void) performDescribeSearchScopeOrder:(BOOL)includeRealTimeEntities
                              failBlock:(ZKFailWithErrorBlock)failBlock
                          completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSearchScopeOrderEnv:includeRealTimeEntities];
	[self startRequest:payload name:@"describeSearchScopeOrder" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeSearchScopeOrderResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the compact layouts of the given sObject */
-(void) performDescribeCompactLayouts:(NSString *)sObjectType recordTypeIds:(NSArray *)recordTypeIds
                            failBlock:(ZKFailWithErrorBlock)failBlock
                        completeBlock:(ZKCompleteDescribeCompactLayoutsResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeCompactLayoutsEnv:sObjectType recordTypeIds:recordTypeIds];
	[self startRequest:payload name:@"describeCompactLayouts" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeCompactLayoutsResult *result = [self makeDescribeCompactLayoutsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the Path Assistants for the given sObject and optionally RecordTypes */
-(void) performDescribePathAssistants:(NSString *)sObjectType picklistValue:(NSString *)picklistValue recordTypeIds:(NSArray *)recordTypeIds
                            failBlock:(ZKFailWithErrorBlock)failBlock
                        completeBlock:(ZKCompleteDescribePathAssistantsResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribePathAssistantsEnv:sObjectType picklistValue:picklistValue recordTypeIds:recordTypeIds];
	[self startRequest:payload name:@"describePathAssistants" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribePathAssistantsResult *result = [self makeDescribePathAssistantsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the approval layouts of the given sObject */
-(void) performDescribeApprovalLayout:(NSString *)sObjectType approvalProcessNames:(NSArray *)approvalProcessNames
                            failBlock:(ZKFailWithErrorBlock)failBlock
                        completeBlock:(ZKCompleteDescribeApprovalLayoutResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeApprovalLayoutEnv:sObjectType approvalProcessNames:approvalProcessNames];
	[self startRequest:payload name:@"describeApprovalLayout" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeApprovalLayoutResult *result = [self makeDescribeApprovalLayoutResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the ListViews as SOQL metadata for the generation of SOQL. */
-(void) performDescribeSoqlListViews:(ZKDescribeSoqlListViewsRequest *)request
                           failBlock:(ZKFailWithErrorBlock)failBlock
                       completeBlock:(ZKCompleteDescribeSoqlListViewResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSoqlListViewsEnv:request];
	[self startRequest:payload name:@"describeSoqlListViews" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeSoqlListViewResult *result = [self makeDescribeSoqlListViewsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Execute the specified list view and return the presentation-ready results. */
-(void) performExecuteListView:(ZKExecuteListViewRequest *)request
                     failBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteExecuteListViewResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeExecuteListViewEnv:request];
	[self startRequest:payload name:@"executeListView" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKExecuteListViewResult *result = [self makeExecuteListViewResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the ListViews of a SObject as SOQL metadata for the generation of SOQL. */
-(void) performDescribeSObjectListViews:(NSString *)sObjectType recentsOnly:(BOOL)recentsOnly isSoqlCompatible:(NSString *)isSoqlCompatible limit:(NSInteger)limit offset:(NSInteger)offset
                              failBlock:(ZKFailWithErrorBlock)failBlock
                          completeBlock:(ZKCompleteDescribeSoqlListViewResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeSObjectListViewsEnv:sObjectType recentsOnly:recentsOnly isSoqlCompatible:isSoqlCompatible limit:limit offset:offset];
	[self startRequest:payload name:@"describeSObjectListViews" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeSoqlListViewResult *result = [self makeDescribeSObjectListViewsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the tabs that appear on a users page */
-(void) performDescribeTabsWithFailBlock:(ZKFailWithErrorBlock)failBlock
              completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeTabsEnv];
	[self startRequest:payload name:@"describeTabs" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeTabsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe all tabs available to a user */
-(void) performDescribeAllTabsWithFailBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeAllTabsEnv];
	[self startRequest:payload name:@"describeAllTabs" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeAllTabsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the primary compact layouts for the sObjects requested */
-(void) performDescribePrimaryCompactLayouts:(NSArray *)sObjectTypes
                                   failBlock:(ZKFailWithErrorBlock)failBlock
                               completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribePrimaryCompactLayoutsEnv:sObjectTypes];
	[self startRequest:payload name:@"describePrimaryCompactLayouts" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribePrimaryCompactLayoutsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Create a set of new sObjects */
-(void) performCreate:(NSArray *)sObjects
            failBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeCreateEnv:sObjects];
	[self startRequest:payload name:@"create" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeCreateResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Update a set of sObjects */
-(void) performUpdate:(NSArray *)sObjects
            failBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeUpdateEnv:sObjects];
	[self startRequest:payload name:@"update" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeUpdateResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Update or insert a set of sObjects based on object id */
-(void) performUpsert:(NSString *)externalIDFieldName sObjects:(NSArray *)sObjects
            failBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeUpsertEnv:externalIDFieldName sObjects:sObjects];
	[self startRequest:payload name:@"upsert" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeUpsertResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Merge and update a set of sObjects based on object id */
-(void) performMerge:(NSArray *)request
           failBlock:(ZKFailWithErrorBlock)failBlock
       completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeMergeEnv:request];
	[self startRequest:payload name:@"merge" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeMergeResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Delete a set of sObjects */
-(void) performDelete:(NSArray *)ids
            failBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDeleteEnv:ids];
	[self startRequest:payload name:@"delete" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDeleteResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Undelete a set of sObjects */
-(void) performUndelete:(NSArray *)ids
              failBlock:(ZKFailWithErrorBlock)failBlock
          completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeUndeleteEnv:ids];
	[self startRequest:payload name:@"undelete" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeUndeleteResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Empty a set of sObjects from the recycle bin */
-(void) performEmptyRecycleBin:(NSArray *)ids
                     failBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeEmptyRecycleBinEnv:ids];
	[self startRequest:payload name:@"emptyRecycleBin" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeEmptyRecycleBinResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Get a set of sObjects */
-(void) performRetrieve:(NSString *)fieldList sObjectType:(NSString *)sObjectType ids:(NSArray *)ids
              failBlock:(ZKFailWithErrorBlock)failBlock
          completeBlock:(ZKCompleteDictionaryBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeRetrieveEnv:fieldList sObjectType:sObjectType ids:ids];
	[self startRequest:payload name:@"retrieve" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSDictionary *result = [self makeRetrieveResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Submit an entity to a workflow process or process a workitem */
-(void) performProcess:(NSArray *)actions
             failBlock:(ZKFailWithErrorBlock)failBlock
         completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeProcessEnv:actions];
	[self startRequest:payload name:@"process" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeProcessResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** convert a set of leads */
-(void) performConvertLead:(NSArray *)leadConverts
                 failBlock:(ZKFailWithErrorBlock)failBlock
             completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeConvertLeadEnv:leadConverts];
	[self startRequest:payload name:@"convertLead" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeConvertLeadResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Logout the current user, invalidating the current session. */
-(void) performLogoutWithFailBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteVoidBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeLogoutEnv];
	[self startRequest:payload name:@"logout" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock();
			});
		}
	}];
}

/** Logs out and invalidates session ids */
-(void) performInvalidateSessions:(NSArray *)sessionIds
                        failBlock:(ZKFailWithErrorBlock)failBlock
                    completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeInvalidateSessionsEnv:sessionIds];
	[self startRequest:payload name:@"invalidateSessions" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeInvalidateSessionsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Get the IDs for deleted sObjects */
-(void) performGetDeleted:(NSString *)sObjectType startDate:(NSDate *)startDate endDate:(NSDate *)endDate
                failBlock:(ZKFailWithErrorBlock)failBlock
            completeBlock:(ZKCompleteGetDeletedResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeGetDeletedEnv:sObjectType startDate:startDate endDate:endDate];
	[self startRequest:payload name:@"getDeleted" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKGetDeletedResult *result = [self makeGetDeletedResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Get the IDs for updated sObjects */
-(void) performGetUpdated:(NSString *)sObjectType startDate:(NSDate *)startDate endDate:(NSDate *)endDate
                failBlock:(ZKFailWithErrorBlock)failBlock
            completeBlock:(ZKCompleteGetUpdatedResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeGetUpdatedEnv:sObjectType startDate:startDate endDate:endDate];
	[self startRequest:payload name:@"getUpdated" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKGetUpdatedResult *result = [self makeGetUpdatedResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Create a Query Cursor */
-(void) performQuery:(NSString *)queryString
           failBlock:(ZKFailWithErrorBlock)failBlock
       completeBlock:(ZKCompleteQueryResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeQueryEnv:queryString];
	[self startRequest:payload name:@"query" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKQueryResult *result = [self makeQueryResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Create a Query Cursor, including deleted sObjects */
-(void) performQueryAll:(NSString *)queryString
              failBlock:(ZKFailWithErrorBlock)failBlock
          completeBlock:(ZKCompleteQueryResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeQueryAllEnv:queryString];
	[self startRequest:payload name:@"queryAll" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKQueryResult *result = [self makeQueryAllResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Gets the next batch of sObjects from a query */
-(void) performQueryMore:(NSString *)queryLocator
               failBlock:(ZKFailWithErrorBlock)failBlock
           completeBlock:(ZKCompleteQueryResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeQueryMoreEnv:queryLocator];
	[self startRequest:payload name:@"queryMore" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKQueryResult *result = [self makeQueryMoreResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Search for sObjects */
-(void) performSearch:(NSString *)searchString
            failBlock:(ZKFailWithErrorBlock)failBlock
        completeBlock:(ZKCompleteSearchResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeSearchEnv:searchString];
	[self startRequest:payload name:@"search" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKSearchResult *result = [self makeSearchResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Gets server timestamp */
-(void) performGetServerTimestampWithFailBlock:(ZKFailWithErrorBlock)failBlock
                    completeBlock:(ZKCompleteGetServerTimestampResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeGetServerTimestampEnv];
	[self startRequest:payload name:@"getServerTimestamp" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKGetServerTimestampResult *result = [self makeGetServerTimestampResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Set a user's password */
-(void) performSetPassword:(NSString *)userId password:(NSString *)password
                 failBlock:(ZKFailWithErrorBlock)failBlock
             completeBlock:(ZKCompleteSetPasswordResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeSetPasswordEnv:userId password:password];
	[self startRequest:payload name:@"setPassword" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKSetPasswordResult *result = [self makeSetPasswordResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Change the current user's password */
-(void) performChangeOwnPassword:(NSString *)oldPassword newPassword:(NSString *)newPassword
                       failBlock:(ZKFailWithErrorBlock)failBlock
                   completeBlock:(ZKCompleteChangeOwnPasswordResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeChangeOwnPasswordEnv:oldPassword newPassword:newPassword];
	[self startRequest:payload name:@"changeOwnPassword" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKChangeOwnPasswordResult *result = [self makeChangeOwnPasswordResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Reset a user's password */
-(void) performResetPassword:(NSString *)userId
                   failBlock:(ZKFailWithErrorBlock)failBlock
               completeBlock:(ZKCompleteResetPasswordResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeResetPasswordEnv:userId];
	[self startRequest:payload name:@"resetPassword" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKResetPasswordResult *result = [self makeResetPasswordResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Returns standard information relevant to the current user */
-(void) performGetUserInfoWithFailBlock:(ZKFailWithErrorBlock)failBlock
             completeBlock:(ZKCompleteUserInfoBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeGetUserInfoEnv];
	[self startRequest:payload name:@"getUserInfo" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKUserInfo *result = [self makeGetUserInfoResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Delete a set of sObjects by example. The passed SOBject is a template for the object to delete */
-(void) performDeleteByExample:(NSArray *)sObjects
                     failBlock:(ZKFailWithErrorBlock)failBlock
                 completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDeleteByExampleEnv:sObjects];
	[self startRequest:payload name:@"deleteByExample" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDeleteByExampleResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Send existing draft EmailMessage */
-(void) performSendEmailMessage:(NSArray *)ids
                      failBlock:(ZKFailWithErrorBlock)failBlock
                  completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeSendEmailMessageEnv:ids];
	[self startRequest:payload name:@"sendEmailMessage" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeSendEmailMessageResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Send outbound email */
-(void) performSendEmail:(NSArray *)messages
               failBlock:(ZKFailWithErrorBlock)failBlock
           completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeSendEmailEnv:messages];
	[self startRequest:payload name:@"sendEmail" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeSendEmailResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Perform a template merge on one or more blocks of text. */
-(void) performRenderEmailTemplate:(NSArray *)renderRequests
                         failBlock:(ZKFailWithErrorBlock)failBlock
                     completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeRenderEmailTemplateEnv:renderRequests];
	[self startRequest:payload name:@"renderEmailTemplate" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeRenderEmailTemplateResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Perform a template merge using an email template stored in the database. */
-(void) performRenderStoredEmailTemplate:(ZKRenderStoredEmailTemplateRequest *)request
                               failBlock:(ZKFailWithErrorBlock)failBlock
                           completeBlock:(ZKCompleteRenderStoredEmailTemplateResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeRenderStoredEmailTemplateEnv:request];
	[self startRequest:payload name:@"renderStoredEmailTemplate" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKRenderStoredEmailTemplateResult *result = [self makeRenderStoredEmailTemplateResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Perform a series of predefined actions such as quick create or log a task */
-(void) performPerformQuickActions:(NSArray *)quickActions
                         failBlock:(ZKFailWithErrorBlock)failBlock
                     completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makePerformQuickActionsEnv:quickActions];
	[self startRequest:payload name:@"performQuickActions" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makePerformQuickActionsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the details of a series of quick actions */
-(void) performDescribeQuickActions:(NSArray *)quickActions
                          failBlock:(ZKFailWithErrorBlock)failBlock
                      completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeQuickActionsEnv:quickActions];
	[self startRequest:payload name:@"describeQuickActions" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeQuickActionsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the details of a series of quick actions in context of requested recordType id for Update actions */
-(void) performDescribeQuickActionsForRecordType:(NSArray *)quickActions recordTypeId:(NSString *)recordTypeId
                                       failBlock:(ZKFailWithErrorBlock)failBlock
                                   completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeQuickActionsForRecordTypeEnv:quickActions recordTypeId:recordTypeId];
	[self startRequest:payload name:@"describeQuickActionsForRecordType" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeQuickActionsForRecordTypeResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe the details of a series of quick actions available for the given contextType */
-(void) performDescribeAvailableQuickActions:(NSString *)contextType
                                   failBlock:(ZKFailWithErrorBlock)failBlock
                               completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeAvailableQuickActionsEnv:contextType];
	[self startRequest:payload name:@"describeAvailableQuickActions" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeAvailableQuickActionsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Retrieve the template sobjects, if appropriate, for the given quick action names in a given context */
-(void) performRetrieveQuickActionTemplates:(NSArray *)quickActionNames contextId:(NSString *)contextId
                                  failBlock:(ZKFailWithErrorBlock)failBlock
                              completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeRetrieveQuickActionTemplatesEnv:quickActionNames contextId:contextId];
	[self startRequest:payload name:@"retrieveQuickActionTemplates" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeRetrieveQuickActionTemplatesResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Retrieve the template sobjects, if appropriate, for the given quick action names in a given contexts when used a mass quick action */
-(void) performRetrieveMassQuickActionTemplates:(NSString *)quickActionName contextIds:(NSArray *)contextIds
                                      failBlock:(ZKFailWithErrorBlock)failBlock
                                  completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeRetrieveMassQuickActionTemplatesEnv:quickActionName contextIds:contextIds];
	[self startRequest:payload name:@"retrieveMassQuickActionTemplates" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeRetrieveMassQuickActionTemplatesResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Describe visualforce for an org */
-(void) performDescribeVisualForce:(BOOL)includeAllDetails namespacePrefix:(NSString *)namespacePrefix
                         failBlock:(ZKFailWithErrorBlock)failBlock
                     completeBlock:(ZKCompleteDescribeVisualForceResultBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeVisualForceEnv:includeAllDetails namespacePrefix:namespacePrefix];
	[self startRequest:payload name:@"describeVisualForce" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			ZKDescribeVisualForceResult *result = [self makeDescribeVisualForceResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Find duplicates for a set of sObjects */
-(void) performFindDuplicates:(NSArray *)sObjects
                    failBlock:(ZKFailWithErrorBlock)failBlock
                completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeFindDuplicatesEnv:sObjects];
	[self startRequest:payload name:@"findDuplicates" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeFindDuplicatesResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Find duplicates for a set of ids */
-(void) performFindDuplicatesByIds:(NSArray *)ids
                         failBlock:(ZKFailWithErrorBlock)failBlock
                     completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeFindDuplicatesByIdsEnv:ids];
	[self startRequest:payload name:@"findDuplicatesByIds" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeFindDuplicatesByIdsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

/** Return the renameable nouns from the server for use in presentation using the salesforce grammar engine */
-(void) performDescribeNouns:(NSArray *)nouns onlyRenamed:(BOOL)onlyRenamed includeFields:(BOOL)includeFields
                   failBlock:(ZKFailWithErrorBlock)failBlock
               completeBlock:(ZKCompleteArrayBlock)completeBlock {

	if (![self confirmLoggedIn]) {
		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
		return;
	}
	NSString *payload = [self makeDescribeNounsEnv:nouns onlyRenamed:onlyRenamed includeFields:includeFields];
	[self startRequest:payload name:@"describeNouns" handler:^(zkElement *root, NSError *err) {
		if (![self handledError:err failBlock:failBlock]) {
			NSArray *result = [self makeDescribeNounsResult:root];
			dispatch_async(dispatch_get_main_queue(), ^{
				completeBlock(result);
			});
		}
	}];
}

@end
